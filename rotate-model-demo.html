<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨¡å‹æ—‹è½¬æ¼”ç¤º - æµ‹é‡ç‚¹è·Ÿéšæ—‹è½¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            min-width: 300px;
            z-index: 100;
        }

        #controls h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #667eea;
            font-weight: bold;
            font-size: 12px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            max-width: 400px;
            z-index: 100;
        }

        #info h3 {
            margin-bottom: 10px;
            color: #fff;
        }

        #info ul {
            list-style: none;
            padding-left: 0;
        }

        #info li {
            margin-bottom: 5px;
            padding-left: 20px;
            position: relative;
        }

        #info li:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #667eea;
        }

        .axis-selector {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .axis-btn {
            flex: 1;
            padding: 8px;
            font-size: 12px;
        }

        .axis-btn.active {
            background: #764ba2;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container"></div>
        
        <div id="controls">
            <h2>ğŸ¯ æ—‹è½¬æ§åˆ¶</h2>
            
            <div class="control-group">
                <label>
                    æ—‹è½¬è§’åº¦: <span class="value-display" id="angle-value">0Â°</span>
                </label>
                <input type="range" id="angle-slider" min="0" max="360" value="0" step="1">
            </div>

            <div class="control-group">
                <label>æ—‹è½¬è½´:</label>
                <div class="axis-selector">
                    <button class="axis-btn active" data-axis="x">Xè½´</button>
                    <button class="axis-btn" data-axis="y">Yè½´</button>
                    <button class="axis-btn" data-axis="z">Zè½´</button>
                </div>
            </div>

            <div class="control-group">
                <button id="reset-btn">é‡ç½®æ—‹è½¬</button>
                <button id="auto-rotate-btn">è‡ªåŠ¨æ—‹è½¬</button>
            </div>

            <div class="control-group">
                <button id="add-point-btn">æ·»åŠ æµ‹é‡ç‚¹</button>
                <button id="clear-points-btn">æ¸…ç©ºæµ‹é‡ç‚¹</button>
            </div>
        </div>

        <div id="info">
            <h3>ğŸ“– ä½¿ç”¨è¯´æ˜</h3>
            <ul>
                <li>æ‹–åŠ¨æ»‘å—æˆ–ç‚¹å‡»æŒ‰é’®æ¥æ—‹è½¬æ¨¡å‹</li>
                <li>æµ‹é‡ç‚¹ä¼šè·Ÿéšæ¨¡å‹ä¸€èµ·æ—‹è½¬</li>
                <li>ç‚¹å‡»"æ·»åŠ æµ‹é‡ç‚¹"åœ¨æ¨¡å‹ä¸Šæ·»åŠ æµ‹é‡æ ‡è®°</li>
                <li>æ—‹è½¬ä¸­å¿ƒå›ºå®šåœ¨æ¨¡å‹ä¸­å¿ƒ</li>
                <li>ä½¿ç”¨é¼ æ ‡æ‹–åŠ¨å¯ä»¥è°ƒæ•´è§†è§’</li>
            </ul>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // åœºæ™¯è®¾ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(5, 5, 5);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // è½¨é“æ§åˆ¶å™¨
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // æ·»åŠ ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // åˆ›å»ºæ¨¡å‹ï¼ˆä¸€ä¸ªå¤æ‚çš„ç»„åˆä½“ï¼‰
        const modelGroup = new THREE.Group();
        scene.add(modelGroup);

        // ä¸»ç«‹æ–¹ä½“
        const boxGeometry = new THREE.BoxGeometry(2, 2, 2);
        const boxMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x667eea,
            metalness: 0.7,
            roughness: 0.3
        });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.castShadow = true;
        box.receiveShadow = true;
        modelGroup.add(box);

        // æ·»åŠ ä¸€äº›è£…é¥°æ€§å‡ ä½•ä½“
        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x764ba2,
            metalness: 0.8,
            roughness: 0.2
        });
        
        const sphere1 = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere1.position.set(1.5, 0, 0);
        sphere1.castShadow = true;
        modelGroup.add(sphere1);

        const sphere2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere2.position.set(-1.5, 0, 0);
        sphere2.castShadow = true;
        modelGroup.add(sphere2);

        const sphere3 = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere3.position.set(0, 1.5, 0);
        sphere3.castShadow = true;
        modelGroup.add(sphere3);

        // æ·»åŠ åæ ‡è½´è¾…åŠ©çº¿
        const axesHelper = new THREE.AxesHelper(3);
        scene.add(axesHelper);

        // æ·»åŠ ç½‘æ ¼åœ°é¢
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);

        // æµ‹é‡ç‚¹ç³»ç»Ÿ
        class MeasureSystem {
            constructor() {
                this.pointArray = [];
                this.points = null;
                this.line = null;
                this.labelGroup = new THREE.Group();
                this.selectGroup = new THREE.Group();
                this.init();
            }

            init() {
                // åˆ›å»ºç‚¹å‡ ä½•ä½“
                const pointGeometry = new THREE.BufferGeometry();
                const pointArray = new Float32Array(500 * 3);
                pointGeometry.setAttribute('position', new THREE.BufferAttribute(pointArray, 3));
                pointGeometry.setDrawRange(0, 0);

                // åˆ›å»ºç‚¹æè´¨
                const pointMaterial = new THREE.PointsMaterial({
                    color: 0xfa6400,
                    size: 0.2,
                    sizeAttenuation: false
                });

                this.points = new THREE.Points(pointGeometry, pointMaterial);
                scene.add(this.points);

                // åˆ›å»ºçº¿å‡ ä½•ä½“
                const lineGeometry = new THREE.BufferGeometry();
                const lineArray = new Float32Array(500 * 3);
                lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineArray, 3));
                lineGeometry.setDrawRange(0, 0);

                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0xfa6400,
                    linewidth: 2
                });

                this.line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(this.line);

                scene.add(this.labelGroup);
                scene.add(this.selectGroup);
            }

            addPoint(position) {
                this.pointArray.push(position.clone());
                this.updateGeometry();
            }

            clearPoints() {
                this.pointArray = [];
                this.updateGeometry();
            }

            updateGeometry() {
                const pointPosition = this.points.geometry.attributes.position;
                const linePosition = this.line.geometry.attributes.position;

                for (let i = 0; i < this.pointArray.length; i++) {
                    const point = this.pointArray[i];
                    pointPosition.setXYZ(i, point.x, point.y, point.z);
                    linePosition.setXYZ(i, point.x, point.y, point.z);
                }

                pointPosition.needsUpdate = true;
                linePosition.needsUpdate = true;
                this.points.geometry.setDrawRange(0, this.pointArray.length);
                this.line.geometry.setDrawRange(0, this.pointArray.length);

                this.points.visible = this.pointArray.length > 0;
                this.line.visible = this.pointArray.length > 0;
            }

            // æ—‹è½¬æ‰€æœ‰æµ‹é‡ç‚¹ï¼Œä½¿å…¶è·Ÿéšæ¨¡å‹æ—‹è½¬
            rotatePoints(center, axis, angle) {
                // åˆ›å»ºæ—‹è½¬å››å…ƒæ•°
                const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                
                // å¯¹æ¯ä¸ªæµ‹é‡ç‚¹åº”ç”¨æ—‹è½¬
                for (let i = 0; i < this.pointArray.length; i++) {
                    const point = this.pointArray[i];
                    // è®¡ç®—ç›¸å¯¹äºæ—‹è½¬ä¸­å¿ƒçš„åç§»
                    const offset = point.clone().sub(center);
                    // åº”ç”¨æ—‹è½¬åˆ°åç§»å‘é‡
                    offset.applyQuaternion(rotationQuaternion);
                    // è®¡ç®—æ–°çš„ä¸–ç•Œä½ç½®
                    point.copy(center.clone().add(offset));
                }
                
                // æ›´æ–°å‡ ä½•ä½“
                this.updateGeometry();
                
                // æ—‹è½¬æ ‡ç­¾ç»„ï¼ˆæ ‡ç­¾ä¹Ÿéœ€è¦è·Ÿéšæ—‹è½¬ï¼‰
                if (this.labelGroup.children.length > 0) {
                    this.labelGroup.children.forEach(label => {
                        if (label instanceof THREE.Object3D) {
                            const labelPosition = new THREE.Vector3();
                            label.getWorldPosition(labelPosition);
                            const offset = labelPosition.clone().sub(center);
                            offset.applyQuaternion(rotationQuaternion);
                            const newPosition = center.clone().add(offset);
                            if (label.parent) {
                                label.parent.updateMatrixWorld();
                                const parentInverseMatrix = new THREE.Matrix4();
                                parentInverseMatrix.copy(label.parent.matrixWorld).invert();
                                const localPosition = newPosition.clone().applyMatrix4(parentInverseMatrix);
                                label.position.copy(localPosition);
                            } else {
                                label.position.copy(newPosition);
                            }
                        }
                    });
                }
                
                // æ—‹è½¬ selectGroup ä¸­çš„çº¿å’Œé¢ï¼ˆMesh å’Œ LineSegmentsï¼‰
                if (this.selectGroup.children.length > 0) {
                    const tempMatrix = new THREE.Matrix4();
                    this.selectGroup.children.forEach(child => {
                        if (child instanceof THREE.Mesh || child instanceof THREE.LineSegments) {
                            const originalObject = child.userData.originalObject;
                            if (originalObject) {
                                // å‘ä¸Šéå†åˆ°æ ¹èŠ‚ç‚¹å¹¶æ›´æ–°æ•´ä¸ªè·¯å¾„
                                let node = originalObject.parent;
                                while (node) {
                                    node.updateMatrixWorld(false);
                                    node = node.parent;
                                }
                                // æœ€åæ›´æ–°åŸå§‹å¯¹è±¡æœ¬èº«
                                originalObject.updateMatrixWorld(false);
                                
                                // å¤åˆ¶æ›´æ–°åçš„çŸ©é˜µåˆ°æµ‹é‡å¯¹è±¡
                                tempMatrix.copy(originalObject.matrixWorld);
                                child.matrix.copy(tempMatrix);
                                child.matrixWorld.copy(tempMatrix);
                            }
                        }
                    });
                }
            }
        }

        const measureSystem = new MeasureSystem();

        // æ§åˆ¶å˜é‡
        let currentAngle = 0;
        let currentAxis = new THREE.Vector3(1, 0, 0); // Xè½´
        let autoRotate = false;
        let rotationCenter = new THREE.Vector3(0, 0, 0);

        // UI æ§åˆ¶
        const angleSlider = document.getElementById('angle-slider');
        const angleValue = document.getElementById('angle-value');
        const axisButtons = document.querySelectorAll('.axis-btn');
        const resetBtn = document.getElementById('reset-btn');
        const autoRotateBtn = document.getElementById('auto-rotate-btn');
        const addPointBtn = document.getElementById('add-point-btn');
        const clearPointsBtn = document.getElementById('clear-points-btn');

        // æ›´æ–°è§’åº¦æ˜¾ç¤º
        function updateAngleDisplay() {
            angleValue.textContent = `${Math.round(currentAngle)}Â°`;
            angleSlider.value = currentAngle;
        }

        // åº”ç”¨æ—‹è½¬
        function applyRotation(angle, axis) {
            const angleRad = THREE.MathUtils.degToRad(angle);
            
            // è®¡ç®—æ—‹è½¬ä¸­å¿ƒï¼ˆæ¨¡å‹ä¸­å¿ƒï¼‰
            const box = new THREE.Box3().setFromObject(modelGroup);
            box.getCenter(rotationCenter);
            
            // åˆ›å»ºæ—‹è½¬å››å…ƒæ•°
            const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angleRad);
            
            // åº”ç”¨æ—‹è½¬åˆ°æ¨¡å‹
            modelGroup.quaternion.multiplyQuaternions(quaternion, modelGroup.quaternion);
            
            // æ—‹è½¬æµ‹é‡ç‚¹
            measureSystem.rotatePoints(rotationCenter, axis, angleRad);
        }

        // è§’åº¦æ»‘å—æ§åˆ¶
        angleSlider.addEventListener('input', (e) => {
            const targetAngle = parseFloat(e.target.value);
            const deltaAngle = targetAngle - currentAngle;
            currentAngle = targetAngle;
            updateAngleDisplay();
            applyRotation(deltaAngle, currentAxis);
        });

        // è½´é€‰æ‹©
        axisButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                axisButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const axis = btn.dataset.axis;
                switch(axis) {
                    case 'x':
                        currentAxis = new THREE.Vector3(1, 0, 0);
                        break;
                    case 'y':
                        currentAxis = new THREE.Vector3(0, 1, 0);
                        break;
                    case 'z':
                        currentAxis = new THREE.Vector3(0, 0, 1);
                        break;
                }
            });
        });

        // é‡ç½®æŒ‰é’®
        resetBtn.addEventListener('click', () => {
            modelGroup.quaternion.set(0, 0, 0, 1);
            currentAngle = 0;
            updateAngleDisplay();
            // é‡ç½®æµ‹é‡ç‚¹ä½ç½®ï¼ˆéœ€è¦é‡æ–°è®¡ç®—ï¼‰
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦ä¿å­˜åˆå§‹ä½ç½®
        });

        // è‡ªåŠ¨æ—‹è½¬
        autoRotateBtn.addEventListener('click', () => {
            autoRotate = !autoRotate;
            autoRotateBtn.textContent = autoRotate ? 'åœæ­¢æ—‹è½¬' : 'è‡ªåŠ¨æ—‹è½¬';
            autoRotateBtn.style.background = autoRotate 
                ? 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)'
                : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        });

        // æ·»åŠ æµ‹é‡ç‚¹
        addPointBtn.addEventListener('click', () => {
            // åœ¨æ¨¡å‹è¡¨é¢éšæœºæ·»åŠ ç‚¹
            const box = new THREE.Box3().setFromObject(modelGroup);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // åœ¨æ¨¡å‹è¡¨é¢ç”Ÿæˆéšæœºç‚¹
            const side = Math.floor(Math.random() * 6);
            let point = new THREE.Vector3();
            
            switch(side) {
                case 0: // å‰é¢
                    point.set(
                        center.x + (Math.random() - 0.5) * size.x,
                        center.y + (Math.random() - 0.5) * size.y,
                        center.z + size.z / 2
                    );
                    break;
                case 1: // åé¢
                    point.set(
                        center.x + (Math.random() - 0.5) * size.x,
                        center.y + (Math.random() - 0.5) * size.y,
                        center.z - size.z / 2
                    );
                    break;
                case 2: // å³é¢
                    point.set(
                        center.x + size.x / 2,
                        center.y + (Math.random() - 0.5) * size.y,
                        center.z + (Math.random() - 0.5) * size.z
                    );
                    break;
                case 3: // å·¦é¢
                    point.set(
                        center.x - size.x / 2,
                        center.y + (Math.random() - 0.5) * size.y,
                        center.z + (Math.random() - 0.5) * size.z
                    );
                    break;
                case 4: // ä¸Šé¢
                    point.set(
                        center.x + (Math.random() - 0.5) * size.x,
                        center.y + size.y / 2,
                        center.z + (Math.random() - 0.5) * size.z
                    );
                    break;
                case 5: // ä¸‹é¢
                    point.set(
                        center.x + (Math.random() - 0.5) * size.x,
                        center.y - size.y / 2,
                        center.z + (Math.random() - 0.5) * size.z
                    );
                    break;
            }
            
            // å°†ç‚¹è½¬æ¢åˆ°ä¸–ç•Œåæ ‡
            point.applyMatrix4(modelGroup.matrixWorld);
            measureSystem.addPoint(point);
        });

        // æ¸…ç©ºæµ‹é‡ç‚¹
        clearPointsBtn.addEventListener('click', () => {
            measureSystem.clearPoints();
        });

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate) {
                const deltaAngle = 1; // æ¯å¸§æ—‹è½¬1åº¦
                currentAngle = (currentAngle + deltaAngle) % 360;
                updateAngleDisplay();
                applyRotation(deltaAngle, currentAxis);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆå§‹åŒ–
        updateAngleDisplay();
        animate();
    </script>
</body>
</html>